// 
// Marinette's commands




////////////////////////////////////////////////////////////
// Any session type
////////////////////////////////////////////////////////////

command "help", ["h", "?"], Const.any, Messages.HelpEntryHelp, function(arguments)
    commands = Helps.indexes
    if arguments.len != 0 then commands = arguments

    foundHelps = {}

    for command in commands
        if Commands.indexes.indexOf(command) == null then
            for kv in Aliases
                if kv.value.indexOf(command) != null then
                    command = kv.key
                    break
                end if
            end for
            if Commands.indexes.indexOf(command) == null then
                continue
            end if
        end if
        if Aliases.indexes.indexOf(command) != null then 
            aliases = Aliases[command]
            commands = [command] + aliases
        else
            commands = [command]
        end if
        commands = commands.join(", ")
        categories = Messages.HelpUndeterminedDescription
        args = Messages.HelpNoArguments
        description = Messages.HelpUndeterminedDescription

        if Helps.indexes.indexOf(command) != null then
            help = Helps[command]
            parts = help.split(" - ")

            if parts.len == 1 then 
                description = parts[0]
            else if parts.len == 2 then
                categories = parts[0]
                description = parts[1]
            else if parts.len == 3 then
                categories = parts[0]
                args = parts[1]
                description = parts[2]
            end if
        end if
        
        help = {
            "commands": commands,
            "args": args,
            "description": description,
        }

        if foundHelps.indexes.indexOf(categories) == null then foundHelps[categories] = []
        foundHelps[categories].push(help)
    end for

    printCategories = function(categories)
        print(primary("<b><--"+categories+"--></b>"))
        for help in foundHelps[categories]
            print(primary(help.commands)+secondary(" - "+help.args+" - "+help.description))
        end for
    end function

    if foundHelps.len > 0 then 
        categories = removeDuplicates(foundHelps.indexes)
        for category in categories
            foundHelps[category].sort("commands")
        end for
        typePredicate = function(iItem, jItem)
            priority = {
                Messages.SessionTypeAny: "A"*32,
                Messages.SessionTypeHost: "A"*31+"B",
                Messages.SessionTypeShell: "A"*31+"C",
                Messages.SessionTypeComputer: "A"*31+"D",
                Messages.SessionTypeFile: "A"*31+"E",
                Messages.HelpUndeterminedDescription: "A"*31+"F",
            }
            if priority.indexes.indexOf(iItem) == null then priority[iItem] = iItem
            if priority.indexes.indexOf(jItem) == null then priority[jItem] = jItem
            return priority[iItem] > priority[jItem]
        end function
        mergeSort(categories, @typePredicate)

        last = categories.pop
        for category in categories
            printCategories(category)
            print(" ")
        end for
        printCategories(last)
    else
        Console.error(Messages.ErrorNoHelpEntries)
    end if
end function


command "credits", [], Const.any, Messages.HelpEntryLicense, function(arguments)
    Conditions.arguments(arguments, 0)

    contributors = [
        "Kurouzu", "Joe Strout", "Clover", "Roupi",
        "Finko42", "Ariavne", "Guest", "Simonize", "Olipro", "Volk",
    ]

    print(primary(Messages.SpecialThanksAndCredits))
    print(" ")
    print(primary(contributors.join(", ")))
    print(" ")
    print(primary(Messages.YouAreAllAwesome+" <3"))
end function


command "exit", ["quit", "q"], Const.any, Messages.HelpEntryQuit, function(arguments)
    Conditions.arguments(arguments, 0)

    Console.log(Messages.LogThanksAndQuit)
    exit
end function


command "cls", ["clear"], Const.any, Messages.HelpEntryClear, function(arguments)
    Conditions.arguments(arguments, 0)

    clear_screen
end function


command "sessions", [], Const.any, Messages.HelpEntrySm, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    
    command = arguments.pull
    if "add".indexOf(command) == 0  and arguments.len != 0 then return Conditions.arguments(arguments, 1)
    if "delete".indexOf(command) == 0 and arguments.len == 0 then return Conditions.argumentsMoreThan(arguments, 1)
    if "use".indexOf(command) == 0 and arguments.len != 1 then return Conditions.arguments(arguments, 2)
    if "look".indexOf(command) == 0 and arguments.len != 0 then return Conditions.argumentsMoreThan(arguments, 1)

    if "add".indexOf(command) == 0 then
        SessionsHelpers.add(Intrinsics)
        Console.log(Messages.LogSuccessfullSessionsUpdate)
    else if "delete".indexOf(command) == 0 then
        i = 0; while i < arguments.len; i = i + 1
            id = arguments[i-1]
            if id isa string or not SessionsHelpers.delete(id) then
                Console.error(Messages.ErrorIncorrectSessionId)
            else
                j = i-1; while j < arguments.len; j = j + 1
                    arguments[j-1] = arguments[j-1] - 1
                end while
                Console.log(Messages.LogSuccessfullSessionDeletion, {"ID": id})
            end if
        end while
    else if "use".indexOf(command) == 0 then
        id = arguments[0]
        if id isa string or not SessionsHelpers.get(id) then return Console.error(Messages.ErrorIncorrectSessionId)
        globals.Intrinsics = SessionsHelpers.get(id)
        Console.log(Messages.LogSuccessfullSessionLoad)
    else if "look".indexOf(command) == 0 then
        output = Messages.SmHeader
        i = 1
        while SessionsHelpers.get(i) != null
            intrinsics = SessionsHelpers.get(i)
            output = output+char(10)+(i)+" "+SessionsHelpers.generateSessionName(intrinsics)
            i = i + 1
        end while
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "theme", [], Const.any, Messages.HelpEntryTheme, function(arguments)
    Conditions.arguments(arguments, 0)
    
    asciiArt = [
        "  __  __          _          _   _       ",
        " |  \/  |__ _ _ _(_)_ _  ___| |_| |_ ___ ",
        " | |\/| / _` | '_| | ' \/ -_)  _|  _/ -_)",
        " |_|  |_\__,_|_| |_|_||_\___|\__|\__\___|",
    ]
    Console.asciiArt(asciiArt)

    print(" ")

    Console.log(randomString(40))
    Console.warning(randomString(40))
    Console.error(randomString(40))

    print(" ")
    table = [
        randomString(10)+" "+randomString(10)+" "+randomString(10)+" "+randomString(10),
        randomString(11)+" "+randomString(11)+" "+randomString(11)+" "+randomString(11),
        randomString(12)+" "+randomString(12)+" "+randomString(12)+" "+randomString(12),
    ].join(char(10))
    print(formatColumnsColored(table, Theme.miscPrimary, Theme.miscSecondary))
end function


command "hashes", [], Const.any, Messages.HelpEntryHashcrack, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.crypto

    crypto = Libs.crypto
    
    Console.log(Messages.LogHashCracking)
    for md5hash in fmap(@str, arguments)
        name = md5hash
        toCrack = md5hash
        if md5hash.indexOf(":") != null then
            parts = md5hash.split(":")
            name = parts[0]
            toCrack = parts[1]
        end if
        
        // 
        // This is a desync fix
        wait(0.01)

        result = crypto.decipher(toCrack)
        if not result then
            Console.error(replaceF(Messages.ErrorUncrackableHash, {"HASH": name}))
        else
            Console.log(replaceF(Messages.LogSuccessfullHashCracking, {"HASH": name, "PASSWORD": result}))
        end if
    end for
end function


command "whois", ["wi"], Const.any, Messages.HelpEntryWhois, function(arguments)
    Conditions.network

    whoisOne = function(addr)
        router = getNetworkNode(addr)
        if not router then return Console.error(Messages.ErrorIncorrectNetworkAddress)
        addr = router.public_ip

        output = whois(addr)
        lines = output.split(char(10))

        domain = getDomainName(addr)
        email = getDomainEmailAddress(addr)
        phone = getDomainPhoneNumber(addr)
        admin = getAdministrativeContact(addr)
        if not domain or not admin or not email or not phone then return Console.error(Messages.ErrorFailedWhoisLookup)
        Console.log(replaceF(Messages.LogWhoisLookup, {"ADDRESS": addr}))
        lines = [
            "<color="+Theme.miscPrimary+">"+Messages.WhoisDomain+" - <color="+Theme.miscSecondary+">"+domain,
            "<color="+Theme.miscPrimary+">"+Messages.WhoisEmail+" - <color="+Theme.miscSecondary+">"+email,
            "<color="+Theme.miscPrimary+">"+Messages.WhoisPhoneNumber+" - <color="+Theme.miscSecondary+">"+phone,
            "<color="+Theme.miscPrimary+">"+Messages.WhoisAdministrator+" - <color="+Theme.miscSecondary+">"+admin,
        ]
        print(lines.join(char(10)))
    end function

    if arguments.len == 0 then
        whoisOne(getNetworkNode.public_ip)
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for path in arguments
            whoisOne(path)
            print(" ")
        end for
        whoisOne(last)
    end if
end function




////////////////////////////////////////////////////////////
// Host session type
////////////////////////////////////////////////////////////

command "systeminfo", ["si"], Const.host, Messages.HelpEntrySysinf, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.host

    shell = get_shell
    computer = shell.host_computer

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfLocalSystem+"-->")
    if user_bank_number then bank = user_bank_number else bank = error(Messages.SysInfUnavailable)
    if user_mail_address then mail = user_mail_address else mail = error(Messages.SysInfUnavailable)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfUserName+" <color="+Theme.miscSecondary+">- "+active_user)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfHostName+" <color="+Theme.miscSecondary+">- "+computer.get_name)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfHomePath+" <color="+Theme.miscSecondary+">- "+home_dir)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfBankLogin+" <color="+Theme.miscSecondary+">- "+bank)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfEmail+" <color="+Theme.miscSecondary+">- "+mail)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfProgramPath+" <color="+Theme.miscSecondary+">- "+program_path)
    print("")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfNetwork+"-->")
    bssid = error(Messages.SysInfUnavailable)
    essid = error(Messages.SysInfUnavailable)
    kernel = error(Messages.SysInfUnavailable)
    localIp = error(Messages.SysInfUnavailable)
    publicIp = error(Messages.SysInfUnavailable)
    deviceIp = error(Messages.SysInfUnavailable)
    if computer.is_network_active then
        router = getNetworkNode
        bssid = router.bssid_name
        essid = router.essid_name
        kernel = router.kernel_version
        localIp = router.local_ip
        publicIp = router.public_ip
        deviceIp = computer.local_ip
    end if
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfMacAddress+" <color="+Theme.miscSecondary+">- "+bssid)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfNetworkName+" <color="+Theme.miscSecondary+">- "+essid)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfKernelVersion+" <color="+Theme.miscSecondary+">- "+kernel)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfLocalAddress+" <color="+Theme.miscSecondary+">- "+localIp)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfPublicAddress+" <color="+Theme.miscSecondary+">- "+publicIp)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfDeviceAddress+" <color="+Theme.miscSecondary+">- "+deviceIp)
    print(" ")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfLibraries+"-->")
    crypto = error(Messages.SysInfNotLoaded)
    apt = error(Messages.SysInfNotLoaded)
    metaxploit = error(Messages.SysInfNotLoaded)
    blockchain = error(Messages.SysInfNotLoaded)
    if Libs.indexes.indexOf("crypto") != null then crypto = Messages.SysInfLoaded
    if Libs.indexes.indexOf("apt") != null then apt = Messages.SysInfLoaded
    if Libs.indexes.indexOf("metaxploit") != null then metaxploit = Messages.SysInfLoaded
    if Libs.indexes.indexOf("blockchain") != null then blockchain = Messages.SysInfLoaded
    print("<color="+Theme.miscPrimary+">Crypto <color="+Theme.miscSecondary+">- "+crypto)
    print("<color="+Theme.miscPrimary+">Apt <color="+Theme.miscSecondary+">- "+apt)
    print("<color="+Theme.miscPrimary+">Metaxploit <color="+Theme.miscSecondary+">- "+metaxploit)
    print("<color="+Theme.miscPrimary+">Blockchain <color="+Theme.miscSecondary+">- "+blockchain)
    print(" ")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfMiscellaneous+"-->")
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfDateTime+" <color="+Theme.miscSecondary+">- "+current_date)
end function


command "reload", ["rl"], Const.host, Messages.HelpEntryReload, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.host

    RuntimeHelpers.makeNeccessaryRuntimeAssigns
    RuntimeHelpers.checkIfEverythingIsAssigned
end function


command "su", [], Const.host, Messages.HelpEntryUserchange, function(arguments)
    Conditions.arguments(arguments, 2)
    Conditions.host

    user = str(arguments[0])
    pass = str(arguments[1])
    
    shell = get_shell(user, pass)
    if not shell then
        Console.error(Messages.ErrorIncorrectUsernameOrPassword)
    else
        Console.log(Messages.LogLookingForMyself)
        // Now that I think of it - this is potentially a security vulnerability. Should be cautious.
        fd = findMyself(get_shell, Config.identificator, "--identify-marinette --password "+Var.password)
        if not fd then return Console.error(Messages.ErrorCouldNotFindMyself)

        Intrinsics.shell = shell
        Intrinsics.computer = Intrinsics.shell.host_computer
        Intrinsics.file = Intrinsics.computer.File("/")
        
        RuntimeHelpers.startMarinette(shell, fd.path)
    end if
end function


command "netcat", ["ncat", "nc"], Const.host, Messages.HelpEntrySvcon, function(arguments)
    Conditions.arguments(arguments, 6)
    Conditions.host
    Conditions.network

    addr = str(arguments[0])
    locAddr = str(arguments[1])
    port = arguments[2]
    user = str(arguments[3])
    pass = str(arguments[4])
    svc = str(arguments[5])


    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    svcPort = getExactPort(addr, locAddr, port)
    if not svcPort then return Console.error(Messages.ErrorCouldNotAccessSuchPort)

    target = addr
    if isNodeLocallyAccessible(router) then target = locAddr
    result = Intrinsics.shell.connect_service(addr, port, user, pass, svc)
    if not result then return Console.error(Messages.ErrorConnectionFailed)
    if ["shell", "ftpshell"].indexOf(typeof(result)) == null then Console.error(Messages.ErrorConnectionUnknownShell)
    
    intrinsics = deepCopy(Intrinsics)
    intrinsics.shell = result
    intrinsics.computer = intrinsics.shell.host_computer
    intrinsics.file = intrinsics.computer.File("/")
    intrinsics.publicAddress = intrinsics.computer.public_ip
    intrinsics.localAddress = intrinsics.computer.local_ip
    intrinsics.port = port
    intrinsics.isConnectionRemote = true
    
    SessionsHelpers.add(intrinsics)
    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


// 
// Thanks Ariavne for allowing me to use their nickname as a tool name :D
command "ariadne", ["aria"], Const.host, Messages.HelpEntryAriadne, function(arguments)
    Conditions.host
    Conditions.metaxploit

    fd = Intrinsics.file
    metaxploit = Libs.metaxploit
    
    while fd.parent
        fd = fd.parent
    end while

    Console.log(Messages.LogSearchingForLocalLibraries)
    metalibs = []
    files = [] + fd.get_folders + fd.get_files
    while files.len > 0
        fd = files.pull
        if fd.is_folder then 
            files = fd.get_folders + fd.get_files + files
            continue
        end if

        if not fd.is_binary then continue
        metalib = metaxploit.load(fd.path)
        if not metalib then continue
        isAlreadyFound = false
        for foundLib in metalibs
            if foundLib.lib_name == metalib.lib_name and foundLib.version == metalib.version then
                isAlreadyFound = true
                break
            end if
        end for
        if not isAlreadyFound then metalibs.push(metalib)
    end while
    
    Console.log(Messages.LogScanningLocalLibraries, {"AMOUNT": metalibs.len})
    exploits = []
    for metalib in metalibs
        memory = metaxploit.scan(metalib)
        for address in memory
            vulners = scanMemoryAddress(metaxploit, metalib, address)
            exploits.push({"metalib": metalib, "address": address, "vulners": vulners})
        end for
    end for

    if exploits.len == 0 then return Console.error(Messages.ErrorNoExploitsInScannedLibraries)
    
    Console.log(Messages.LogExploitingVulnerabilities)
    results = []
    for exploit in exploits
        for vulner in exploit.vulners
            ofArgs = [null]
            if arguments.len > 0 then ofArgs = ofArgs + fmap(@str, arguments)
            ofArgs = removeDuplicates(ofArgs)
            for ofArg in ofArgs
                // 
                // This is a desync fix
                wait(0.01)
                if ofArg == null then
                    result = exploit.metalib.overflow(exploit.address, vulner.value)
                else
                    result = exploit.metalib.overflow(exploit.address, vulner.value, ofArg)
                end if
                if result == null then continue
                object = result
                result = {
                    "publicAddr": Intrinsics.publicAddress,
                    "localAddr": Intrinsics.localAddress,
                    "metalib": exploit.metalib,
                    "address": exploit.address,
                    "vulner": vulner,
                    "ofArg": null,
                    "object": object,
                }
                if ofArg != null then result.ofArg = ofArg
                results.push(result)
            end for
        end for
    end for

    if results.len == 0 then return Console.error(Messages.ErrorNoVulnerabilitiesInLibraries)

    Console.log(Messages.LogAddingNewSessions)
    for result in results
        object = result.object
        type = typeof(object)

        if object isa string or object isa number then continue

        intrinsics = deepCopy(Intrinsics)
        intrinsics.shell = null
        intrinsics.computer = null
        intrinsics.file = null
        intrinsics.publicAddress = result.publicAddr
        intrinsics.localAddress = result.localAddr
        intrinsics.isConnectionRemote = true

        if type == "shell" then
            intrinsics.shell = object
            intrinsics.computer = intrinsics.shell.host_computer
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "computer" then
            intrinsics.computer = object
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "file" then
            fd = object
            while fd.parent
                fd = fd.parent
            end while
            intrinsics.file = fd
        end if

        SessionsHelpers.add(intrinsics)
    end for

    Console.log(Messages.LogCompilingExploitResults)
    outputs = {}
    for result in results
        library = result.metalib.lib_name
        version = result.metalib.version
        address = result.address
        vulner = result.vulner.value
        ofArg = ""
        object = result.object
        type = typeof(object)
        if result.ofArg then ofArg = result.ofArg

        key = [library,version,ofArg].join(" ")
        if outputs.indexes.indexOf(key) == null then
            outputs[key] = [address,vulner,type].join(" ")
        else
            outputs[key] = outputs[key]+char(10)+[address,vulner,type].join(" ")
        end if
    end for

    if outputs.len == 0 then return Console.error(Messages.ErrorNoUsefullExploits)

    Console.log(Messages.LogUsefullExploits)
    counter = 0
    for kv in outputs
        Console.log(Messages.LogVulnerabilitesIn, {"LIBRARY": kv.key})
        output = Messages.ExploitsHeader+char(10)+kv.value

        lines = output.split(char(10))
        typePredicate = function(iItem, jItem)
            priority = {
                "shell": 0,
                "computer": 1,
                "file": 2, 
                "string": 3,
                "number": 4,
            }
            iType = iItem.split(" ")[2]
            jType = jItem.split(" ")[2]
            return priority[iType] > priority[jType]
        end function
        mergeSort(lines, @typePredicate, 1)
        
        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))

        counter = counter + 1
        if counter != outputs.len then print(" ")
    end for

    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


command "nemesis", ["ns"], Const.host, Messages.HelpEntryNemesis, function(arguments)
    Conditions.argumentsMoreThan(arguments, 2)
    Conditions.host
    Conditions.network
    Conditions.metaxploit

    metaxploit = Libs.metaxploit

    addr = str(arguments.pull)
    argLocAddr = str(arguments.pull)
    argPort = arguments.pull
    ofArgs = [null]

    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    ofArgs = ofArgs + fmap(@str, arguments) + router.devices_lan_ip

    targets = []
    if isNodeLocallyAccessible(router) then
        for port in getPublicPortsWithLocalStates(addr) + getLocalPorts(addr)
            target = {
                "publicAddr": router.public_ip,
                "localAddr": port.get_lan_ip,
                "ip": port.get_lan_ip,
                "port": port.port_number,
            }
            targets.push(target)
        end for
        for localAddr in router.devices_lan_ip
            node = null
            isRouter = false
            if isNodeLocallyAccessible(router) then
                node = getNetworkNode(localAddr)
                if node then isRouter = true
            end if
            if isRouter then
                ofArgs = ofArgs + node.devices_lan_ip
                target = {
                    "publicAddr": node.public_ip,
                    "localAddr": localAddr,
                    "ip": localAddr,
                    "port": 0,
                }
                targets.push(target)
            end if
        end for
    else
        for port in router.used_ports
            target = {
                "publicAddr": router.public_ip,
                "localAddr": port.get_lan_ip,
                "ip": router.public_ip,
                "port": port.port_number,
            }
            targets.push(target)
        end for
        target = {
            "publicAddr": router.public_ip,
            "localAddr": router.local_ip,
            "ip": router.public_ip,
            "port": 0,
        }
        targets.push(target)
    end if
    targets = removeDuplicates(targets)
    ofArgs = removeDuplicates(ofArgs)

    libraries = []
    for target in targets
        if "all".indexOf(argLocAddr) != 0 and target.localAddr != argLocAddr then continue
        if "all".indexOf(argPort) != 0 and target.port != argPort then continue
        netSession = metaxploit.net_use(target.ip, target.port)
        if not netSession then continue
        metalib = netSession.dump_lib
        library = {
            "publicAddr": target.publicAddr,
            "localAddr": target.localAddr,
            "port": target.port,
            "metalib": metalib,
        }
        libraries.push(library)
    end for

    Console.log(Messages.LogScanningRemoteLibraries, {"AMOUNT": libraries.len})
    exploits = []
    for library in libraries
        memory = metaxploit.scan(library.metalib)
        for address in memory
            vulners = scanMemoryAddress(metaxploit, library.metalib, address)
            exploit = {
                "publicAddr": library.publicAddr,
                "localAddr": library.localAddr,
                "port": library.port,
                "metalib": library.metalib,
                "address": address,
                "vulners": vulners,
            }
            exploits.push(exploit)
        end for
    end for

    if exploits.len == 0 then return Console.error(Messages.ErrorNoExploitsInScannedLibraries)
    
    Console.log(Messages.LogExploitingVulnerabilities)
    results = []
    for exploit in exploits
        for vulner in exploit.vulners
            ofArgs = [null]
            if arguments.len > 0 then ofArgs = ofArgs + arguments
            ofArgs = removeDuplicates(ofArgs)
            for ofArg in ofArgs
                // 
                // This is a desync fix
                wait(0.01)
                if ofArg == null then
                    result = exploit.metalib.overflow(exploit.address, vulner.value)
                else
                    result = exploit.metalib.overflow(exploit.address, vulner.value, str(ofArg))
                end if
                if result == null then continue
                object = result
                result = {
                    "publicAddr": exploit.publicAddr,
                    "localAddr": exploit.localAddr,
                    "port": exploit.port,
                    "metalib": exploit.metalib,
                    "address": exploit.address,
                    "vulner": vulner,
                    "ofArg": null,
                    "object": object,
                }
                if ofArg != null then result.ofArg = ofArg
                results.push(result)
            end for
        end for
    end for

    if results.len == 0 then return Console.error(Messages.ErrorNoVulnerabilitiesInLibraries)

    Console.log(Messages.LogAddingNewSessions)
    for result in results
        object = result.object
        type = typeof(object)

        if object isa string or object isa number then continue

        intrinsics = deepCopy(Intrinsics)
        intrinsics.shell = null
        intrinsics.computer = null
        intrinsics.file = null
        intrinsics.publicAddress = result.publicAddr
        intrinsics.localAddress = result.localAddr
        intrinsics.port = result.port
        intrinsics.isConnectionRemote = true

        if type == "shell" then
            intrinsics.shell = object
            intrinsics.computer = intrinsics.shell.host_computer
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "computer" then
            intrinsics.computer = object
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "file" then
            fd = object
            while fd.parent
                fd = fd.parent
            end while
            intrinsics.file = fd
        end if

        if result.ofArg != null and is_valid_ip(result.ofArg) then intrinsics.localAddress = result.ofArg

        SessionsHelpers.add(intrinsics)
    end for

    Console.log(Messages.LogCompilingExploitResults)
    outputs = {}
    for result in results
        library = result.metalib.lib_name
        version = result.metalib.version
        address = result.address
        vulner = result.vulner.value
        ofArg = ""
        object = result.object
        type = typeof(object)
        if result.ofArg then ofArg = result.ofArg

        key = [library,version,ofArg].join(" ")
        if outputs.indexes.indexOf(key) == null then
            outputs[key] = [address,vulner,type].join(" ")
        else
            outputs[key] = outputs[key]+char(10)+[address,vulner,type].join(" ")
        end if
    end for

    if outputs.len == 0 then return Console.error(Messages.ErrorNoUsefullExploits)

    Console.log(Messages.LogUsefullExploits)
    counter = 0
    for kv in outputs
        Console.log(Messages.LogVulnerabilitesIn, {"LIBRARY": kv.key})
        output = Messages.ExploitsHeader+char(10)+kv.value

        lines = output.split(char(10))
        typePredicate = function(iItem, jItem)
            priority = {
                "shell": 0,
                "computer": 1,
                "file": 2, 
                "string": 3,
                "number": 4,
            }
            iType = iItem.split(" ")[2]
            jType = jItem.split(" ")[2]
            return priority[iType] > priority[jType]
        end function
        mergeSort(lines, @typePredicate, 1)
        
        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))

        counter = counter + 1
        if counter != outputs.len then print(" ")
    end for

    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


command "addresses", [], Const.host, Messages.HelpEntryRaddr, function(arguments)
    Conditions.argumentsFewerThan(arguments, 2)
    Conditions.host
    Conditions.network

    count = arguments.pull
    if count == null then count = 1
    if not count isa number then return Console.error(Messages.ErrorUnknownArguments)
    if count < 1 then return

    Console.log(Messages.LogGeneratingRandomAddresses)
    i = 0; while i < count; i = i + 1
        print("<color="+Theme.miscPrimary+">"+randomNetworkAddress+"</color>")
    end while
    Console.log(Messages.LogDoneGeneratingRandomAddresses)
end function


command "findservice", ["findsvc"], Const.host, Messages.HelpEntrySvcfind, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.argumentsFewerThan(arguments, 3)
    Conditions.host
    Conditions.network

    service = str(arguments[0])
    serviceVersion = null
    if arguments.len == 2 then serviceVersion = str(arguments[1])

    if "gateway".indexOf(service.lower) == 0 then service = Messages.ServiceNode

    while true
        ip = randomNetworkAddress
        router = getNetworkNode(ip)
        if service == Messages.ServiceNode then
            if not serviceVersion or (router.kernel_version == serviceVersion) then
                return Console.log(Messages.LogServiceFound, {"SERVICE": Messages.ServiceNode+" "+router.kernel_version, "ADDRESS":ip, "PORT": 0})
            end if
        else
            for port in router.used_ports
                info = router.port_info(port)
                if info.indexOf(service) != null then
                    if not serviceVersion or (serviceVersion and info.indexOf(serviceVersion) != null) then
                        return Console.log(Messages.LogServiceFound, {"SERVICE": info, "ADDRESS":ip, "PORT": port.port_number})
                    end if
                end if
            end for
        end if
        version = ""
        if serviceVersion then version = " "+serviceVersion
        Console.error(Messages.ErrorServiceNotFound, {"SERVICE": service+version, "ADDRESS": ip})
    end while
end function


command "lib", [], Const.host, Messages.HelpEntryInspect, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.host
    Conditions.metaxploit

    metaxploit = Libs.metaxploit

    inspectOne = function(path)
        fd = iterateToPath(Intrinsics.file, path)

        metalib = null
        if fd then metalib = metaxploit.load(fd.path)
        if not metalib then return Console.error(Messages.ErrorIncorrectLibraryPath)

        object = null
        if fd then object = include_lib(fd.path)

        if not object then
            objectType = "library"
        else
            objectType = typeof(object).lower
            for removal in ["lib", "client"]
                objectType = objectType.replace(removal, "")
            end for
        end if

        Console.log(replaceF(Messages.LogLibraryAt, {"PATH": fd.path}))
        print("<color="+Theme.miscPrimary+">"+Messages.InspectLibraryType+" - <color="+Theme.miscSecondary+">"+objectType)
        print("<color="+Theme.miscPrimary+">"+Messages.InspectLibraryName+" - <color="+Theme.miscSecondary+">"+metalib.lib_name)
        print("<color="+Theme.miscPrimary+">"+Messages.InspectLibraryVersion+" - <color="+Theme.miscSecondary+">"+metalib.version)
    end function

    arguments = fmap(@str, arguments)
    last = arguments.pop
    for path in arguments
        inspectOne(path)
        print(" ")
    end for
    inspectOne(last)
end function


command "wificrack", [], Const.host, Messages.HelpEntryNetcrack, function(arguments)
    Conditions.arguments(arguments, 2)
    Conditions.host
    Conditions.crypto

    crypto = Libs.crypto
    iface = str(arguments[0])
    id = arguments[1]

    lines = Intrinsics.computer.network_devices.split(char(10))
    i = 0; while i < lines.len; i = i + 1
        parts = lines[i-1].split(" ")
        lines[i-1] = parts[0]
    end while
    ifaces = lines
    eth = ifaces.indexOf("eth")
    if eth != null then ifaces.remove(eth)
    if ifaces.indexOf(iface) == null then return Console.error(Messages.ErrorIncorrectNetworkInterface)

    networks = Intrinsics.computer.wifi_networks(iface)
    if not networks then return Console.error(Messages.ErrorCouldNotGetNetworksList)
    if not id isa number or id > networks.len then return Console.error(Messages.ErrorIncorrectNetworkId)
    
    Console.log(Messages.LookingForTheNetwork)
    powerPredicate = function(iItem, jItem)
        iPwr = iItem.split(" ")[1].replace("%", "").to_int
        jPwr = jItem.split(" ")[1].replace("%", "").to_int
        return iPwr > jPwr
    end function
    mergeSort(networks, @powerPredicate)

    network = networks[id-1].split(" ")
    bssid = network[0]
    pwr = network[1].replace("%", "").to_int
    essid = network[2]
    acks = ceil(300000 / pwr)

    Console.log(Messages.LogStartingMonitorMode)
    result = crypto.airmon("start", iface)
    if result isa string then
        crypto.airmon("stop", iface)
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "airmon", "ERROR": result}))
    end if

    Console.log(replaceF(Messages.LogAireplayingOn, {"ESSID": essid, "ACKS": acks}))
    result = crypto.aireplay(bssid, essid, acks)
    if result isa string then
        crypto.airmon("stop", iface)
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "aireplay", "ERROR": result}))
    end if

    Console.log(Messages.LogAircrackingTheHandshake)
    password = crypto.aircrack(current_path+"/file.cap")

    cap = get_shell.host_computer.File(current_path+"/file.cap")
    if cap then cap.delete

    Console.log(Messages.LogStoppingMonitorMode)
    crypto.airmon("stop", iface)

    if not password then
        return Console.error(Messages.ErrorFailedPasswordCrack)
    else
        return Console.log(replaceF(Messages.LogSuccessfullPasswordCrack, {"ESSID": essid, "ID": id, "PASSWORD": password}))
    end if
end function


command "meow", ["mpm"], Const.host, Messages.HelpEntryMeow, function(arguments)
    Conditions.argumentsMoreThan(arguments, 1)
    Conditions.host
    Conditions.network
    Conditions.apt
    
    fd = Intrinsics.file
    apt = Libs.apt
    command = str(arguments.pull)

    if "add".indexOf(command) == 0 then
        for repo in fmap(@str, arguments)
            parts = repo.split(":")
            if parts.len > 2 then return Console.error(Messages.ErrorIncorrectRepositoryAddress)
            
            address = parts[0]
            port = 1542
            if parts.len == 2 then port = parts[1].to_int
            
            router = getNetworkNode(address)
            if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
            address = router.public_ip

            if not port isa number then return Console.error(Messages.ErrorCouldNotAccessSuchPort)

            result = apt.add_repo(address, port)
            if result and result isa string then
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "add_repo", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogSuccessfullRepositoryAddition, {"ADDRESS": address, "PORT": port}))
            end if
        end for
    else if "delete".indexOf(command) == 0 then
        for address in fmap(@str, arguments)
            router = getNetworkNode(address)
            if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
            address = router.public_ip

            result = apt.del_repo(address)
            if result and result isa string then 
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "del_repo", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogSuccessfullRepositoryDeletion, {"ADDRESS": address}))
            end if
        end for
    else if "download".indexOf(command) == 0 then
        apt.update
        for package in fmap(@str, arguments)
            result = apt.install(package, fd.path)
            if result and result isa string then
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "install", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogSuccessfullPackageInstallation, {"PACKAGE": package}))
            end if
        end for
    else if "look".indexOf(command) == 0 then
        apt.update
        for address in fmap(@str, arguments)
            router = getNetworkNode(address)
            if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
            address = router.public_ip

            result = apt.show(address)
            if result.indexOf(" repository not found") then 
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "show", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogContentsOfRepository, {"ADDRESS": address}))
                lines = result.split(char(10))
                lines.pop
                for line in lines
                    print("<color="+Theme.miscPrimary+">"+line)
                end for
            end if
        end for
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "netscan", ["nesca"], Const.host, Messages.HelpEntryNesca, function(arguments)
    Conditions.host
    Conditions.network

    nescaOne = function(address)
        nodes = []

        router = getNetworkNode(address)
        if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
        nodes.push(router)

        domain = getDomainName(address)
        Console.log(replaceF(Messages.LogNescaOn, {"DOMAIN": domain, "PUBADDR": router.public_ip, "LOCADDR": router.local_ip}))
        
        output = Messages.NescaHeader
        if not isNodeLocallyAccessible(router) then output = output+char(10)+"0 "+Messages.PortStateOpened+" "+Messages.PortStateOpened+" "+Messages.ServiceNode+" "+router.kernel_version+" "+router.local_ip
        for publicPort in router.used_ports
            localAddr = publicPort.get_lan_ip
            port = publicPort.port_number
            pubState = Messages.PortStateClosed
            locState = Messages.PortStateClosed
            info = router.port_info(publicPort)
            if not publicPort.is_closed then pubState = Messages.PortStateOpened
            for localPort in getPublicPortsWithLocalStates(address)
                if localPort.get_lan_ip != localAddr then continue
                if localPort.port_number != port then continue
                if not localPort.is_closed then
                    locState = Messages.PortStateOpened
                    break
                end if
            end for
            output = output+char(10)+[port,pubState,locState,info,localAddr].join(" ")
        end for

        for localPort in getLocalPorts(address)
            localAddr = localPort.get_lan_ip
            port = localPort.port_number
            pubState = Messages.PortStateClosed
            locState = Messages.PortStateClosed
            info = router.port_info(localPort)
            if not localPort.is_closed then locState = Messages.PortStateOpened
            output = output+char(10)+[port,pubState,locState,info,localAddr].join(" ")
        end for

        for localAddr in router.devices_lan_ip
            node = null
            if isNodeLocallyAccessible(router) then node = getNetworkNode(localAddr)
            if not node then continue
            nodes.push(node)

            localAddr = node.local_ip
            port = "0"
            pubState = Messages.PortStateOpened
            locState = Messages.PortStateOpened
            info = Messages.ServiceNode+" "+node.kernel_version
            output = output+char(10)+[port,pubState,locState,info,localAddr].join(" ")
        end for

        for portlessAddr in getPortlessNodes(address)
            output = output+char(10)+"- - - "+Messages.ServiceComputer+" - "+portlessAddr
        end for

        lines = output.split(char(10))
        addrPredicate = function(iItem, jItem)
            iAddr = iItem.split(" ")[5]
            jAddr = jItem.split(" ")[5]
            return iAddr > jAddr
        end function
        compPredicate = function(iItem, jItem)
            iSvc = iItem.split(" ")[3]
            jSvc = jItem.split(" ")[3]
            return iSvc != jSvc and jSvc == Messages.ServiceComputer
        end function
        nodePredicate = function(iItem, jItem)
            iSvc = iItem.split(" ")[3]
            jSvc = jItem.split(" ")[3]
            return iSvc != jSvc and jSvc == Messages.ServiceNode
        end function
        mergeSort(lines, @addrPredicate, 1)
        mergeSort(lines, @compPredicate, 1)
        mergeSort(lines, @nodePredicate, 1)

        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))

        output = Messages.NescaFirewallHeader
        for node in nodes
            for rule in node.firewall_rules
                parts = rule.split(" ")
                action = parts[0]
                port = parts[1]
                source = parts[2]
                dest = parts[3]
                addr = node.local_ip
                output = output+char(10)+[port,action,source,dest,addr].join(" ")
            end for
        end for

        if output == Messages.NescaFirewallHeader then return
        Console.log(replaceF(Messages.LogNescaFirewallOn, {"DOMAIN": domain, "PUBADDR": router.public_ip, "LOCADDR": router.local_ip}))

        lines = output.split(char(10))
        addrPredicate = function(iItem, jItem)
            iAddr = iItem.split(" ")[4]
            jAddr = jItem.split(" ")[4]
            return iAddr > jAddr
        end function
        mergeSort(lines, @addrPredicate, 1)
        
        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
    end function

    if arguments.len == 0 then
        nescaOne(Intrinsics.publicAddress)
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for address in arguments
            nescaOne(str(address))
            print(" ")
        end for
        nescaOne(last)
    end if
end function


command "mails", [], Const.host, Messages.HelpEntryMaildump, function(arguments)
    Conditions.arguments(arguments, 3)
    Conditions.host
    Conditions.network
    Conditions.crypto

    crypto = Libs.crypto

    addr = str(arguments[0])
    locAddr = str(arguments[1])
    port = arguments[2]

    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    smtpPort = getExactPort(addr, locAddr, port)
    if not smtpPort then return Console.error(Messages.ErrorCouldNotAccessSuchPort)
    if router.port_info(smtpPort).indexOf("smtp") == null then return Console.error(replaceF(Messages.ErrorNoServiceOnPort, {"SERVICE": "smtp", "PORT": port}))

    target = addr
    if isNodeLocallyAccessible(router) then target = locAddr
    result = crypto.smtp_user_list(target, port)
    if result isa string then
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "smtp_user_list", "ERROR": result}))
    else if not result then 
        return Console.error(replaceF(Messages.ErrorInvulnerableService, {"SERVICE": "smtp"}))
    end if

    Console.log(replaceF(Messages.LogRegisteredUsersOn, {"DOMAIN": getDomainName(addr), "PUBADDR": router.public_ip, "LOCADDR": locAddr}))
    output = result.join(char(10))
    output = output.replace("email not found", "-")
    output = Messages.MaildumpHeader+char(10)+output
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function




////////////////////////////////////////////////////////////
// Shell and FtpShell session types
////////////////////////////////////////////////////////////

command "hostify", [], Const.shell, Messages.HelpEntryHostify, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.remote
    Conditions.shell(["shell"])
    Conditions.network

    Console.log(Messages.LogLookingForPermissivePathToUploadInto)
    fdPermissive = findPermissivePath(Intrinsics.file, "wx")
    if not fdPermissive then return Console.error(Messages.ErrorCouldNotFindPermissivePathToUploadInto)

    marinettePath = null
    fdMarinette = findMyself(Intrinsics.shell, Config.identificator, "--identify-marinette --password "+Var.password, true)
    if fdMarinette and fdMarinette.has_permission("x") then marinettePath = fdMarinette.path
    if not marinettePath then
        Console.log(Messages.LogLookingForMyself)
        // Now that I think of it - this is potentially a security vulnerability. Should be cautious.
        fdMarinette = findMyself(get_shell, Config.identificator, "--identify-marinette --password "+Var.password)
        if not fdMarinette then return Console.error(Messages.ErrorCouldNotFindMyself)
        
        Console.log(Messages.LogUploadingNeccessary)
        fdBin = get_shell.host_computer.File(fdMarinette.path)
        result = get_shell.scp(fdMarinette.path, fdPermissive.path, Intrinsics.shell)
        if result isa string then
            return Console.error(Messages.ErrorStringGeneral, {"FUNC": "scp", "ERROR": result})
        else if not result then
            return Console.error(Messages.ErrorUnknown)
        end if
        Console.log("<i>"+fdMarinette.path+"</i> -> <i>"+fdPermissive.path)
        marinettePath = fdPermissive.path+"/"+fdMarinette.name
    end if

    Intrinsics.isConnectionRemote = false

    RuntimeHelpers.startMarinette(Intrinsics.shell, marinettePath)
end function


command "cmd", [], Const.shell, Messages.HelpEntryConsole, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.shell(["shell"])

    Console.log(Messages.LogStartingInGameConsole)
    Intrinsics.shell.start_terminal
    exit
end function


command "start", [], Const.shell, Messages.HelpEntryRun, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.shell(["shell"])

    binaryPath = str(arguments.pull)
    binaryArgs = null
    if arguments.len > 0 then binaryArgs = fmap(@str, arguments).join(" ")

    fd = iterateToPath(Intrinsics.file, binaryPath)
    if not fd or not fd.is_binary then return Console.error(Messages.ErrorPathDoesntExistOrNotBinary)

    Console.log(Messages.LogRunningBinary)
    if not binaryArgs then
        result = Intrinsics.shell.launch(fd.path)
    else
        result = Intrinsics.shell.launch(fd.path, binaryArgs)
    end if

    if result isa string then
        Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "launch", "ERROR": result}))
    else if not result then
        Console.error(Messages.ErrorCouldNotLaunchBinary)
    end if
end function




////////////////////////////////////////////////////////////
// Computer session type
////////////////////////////////////////////////////////////

command "ipconfig", [], Const.computer, Messages.HelpEntryNetint, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.computer

    netdevices = Intrinsics.computer.network_devices.trim
    if netdevices == "" then netdevices = "- - -"

    Console.log(Messages.LogGettingNetworkInterfaces)
    output = Messages.NetintHeader+char(10)+netdevices
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function


command "networks", [], Const.computer, Messages.HelpEntryNetlook, function(arguments)
    Conditions.arguments(arguments, 1)
    Conditions.computer

    iface = str(arguments[0])

    lines = Intrinsics.computer.network_devices.split(char(10))
    i = 0; while i < lines.len; i = i + 1
        parts = lines[i-1].split(" ")
        lines[i-1] = parts[0]
    end while
    ifaces = lines
    eth = ifaces.indexOf("eth")
    if eth != null then ifaces.remove(eth)
    if ifaces.indexOf(iface) == null then return Console.error(Messages.ErrorIncorrectNetworkInterface)

    networks = Intrinsics.computer.wifi_networks(iface)
    if not networks then return Console.error(Messages.ErrorCouldNotGetNetworksList)
    
    powerPredicate = function(iItem, jItem)
        iPwr = iItem.split(" ")[1].replace("%", "").to_int
        jPwr = jItem.split(" ")[1].replace("%", "").to_int
        return iPwr > jPwr
    end function
    mergeSort(networks, @powerPredicate)

    Console.log(Messages.LogSurroundingNetworks)
    output = Messages.NetlookHeader
    i = 0; for network in networks; i = i + 1
        pwr = network.split(" ")[1].replace("%", "").to_int
        acks = ceil(300000 / pwr)
        output = output+char(10)+i+" "+network+" "+acks
    end for
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function


command "connect", [], Const.computer, Messages.HelpEntryNetcon, function(arguments)
    Conditions.arguments(arguments, 3)
    Conditions.computer

    iface = str(arguments[0])
    id = arguments[1]
    password = str(arguments[2])

    lines = Intrinsics.computer.network_devices.split(char(10))
    i = 0; while i < lines.len; i = i + 1
        parts = lines[i-1].split(" ")
        lines[i-1] = parts[0]
    end while
    ifaces = lines
    eth = ifaces.indexOf("eth")
    if eth != null then ifaces.remove(eth)
    if ifaces.indexOf(iface) == null then return Console.error(Messages.ErrorIncorrectNetworkInterface)

    networks = Intrinsics.computer.wifi_networks(iface)
    if not networks then return Console.error(Messages.ErrorCouldNotGetNetworksList)
    if not id isa number or id > networks.len then return Console.error(Messages.ErrorIncorrectNetworkId)
    id = id - 1
    
    Console.log(Messages.LookingForTheNetwork)
    powerPredicate = function(iItem, jItem)
        iPwr = iItem.split(" ")[1].replace("%", "").to_int
        jPwr = jItem.split(" ")[1].replace("%", "").to_int
        return iPwr > jPwr
    end function
    mergeSort(networks, @powerPredicate)

    network = networks[id].split(" ")
    bssid = network[0]
    essid = network[2]

    result = Intrinsics.computer.connect_wifi(iface, bssid, essid, password)
    if result isa string then
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "connect_wifi", "ERROR": result}))
    else
        Console.log(replaceF(Messages.LogConnectedToEssidSuccessfully, {"ESSID": essid}))
    end if

    if Intrinsics.isConnectionRemote then return
    RuntimeHelpers.makeNeccessaryRuntimeAssigns
    RuntimeHelpers.checkIfEverythingIsAssigned
end function


command "tasklist", [], Const.computer, Messages.HelpEntryTasklist, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.computer

    lines = Intrinsics.computer.show_procs.split(char(10))
    tasks = lines[1:]
    if tasks.len == 0 then tasks = ["- - - - -"]
    
    Console.log(Messages.LogAllRunningTasks)
    output = Messages.TasklistHeader+char(10)+tasks.join(char(10))
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function


command "taskkill", [], Const.computer, Messages.HelpEntryTaskill, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.computer

    for pid in removeDuplicates(arguments)
        result = Intrinsics.computer.close_program(pid)
        if result isa string then
            Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "close_program", "ERROR": result}))
        else if not result then
            Console.error(Messages.ErrorUnknown)
        else
            Console.log(Messages.LogSuccessfullyKilledTask)
        end if
    end for
end function


command "newtext", ["nt"], Const.computer, Messages.HelpEntryTextfile, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.computer

    textfileOne = function(path)
        fd = Intrinsics.file
        parts = path.split("/")
        fileName = parts.pop
        path = parts.join("/")
        if path != "" then fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)
        result = Intrinsics.computer.touch(fd.path, fileName)
        if result isa string then
            Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "touch", "ERROR": result}))
        else if not result then
            Console.error(Messages.ErrorUnknown)
        else
            Console.log(Messages.LogFileHasBeenCreatedSuccessfully)
        end if
    end function

    for path in fmap(@str, arguments)
        textfileOne(path)
    end for
end function


command "newdir", ["nd"], Const.computer, Messages.HelpEntryDirectory, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.computer

    directoryOne = function(path)
        fd = Intrinsics.file
        parts = path.split("/")
        fileName = parts.pop
        path = parts.join("/")
        if path != "" then fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)
        result = Intrinsics.computer.create_folder(fd.path, fileName)
        if result isa string then
            Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "create_folder", "ERROR": result}))
        else if not result then
            Console.error(Messages.ErrorUnknown)
        else
            Console.log(Messages.LogDirectoryHasBeenCreatedSuccessfully)
        end if
    end function

    for path in fmap(@str, arguments)
        directoryOne(path)
    end for
end function




////////////////////////////////////////////////////////////
// File session type
////////////////////////////////////////////////////////////

command "chdir", ["cd", "walk", "w"], Const.file, Messages.HelpEntryWalk, function(arguments)
    Conditions.arguments(arguments, 2)

    command = str(arguments[0])
    s = arguments[1]
    path = str(arguments[1])

    fd = Intrinsics.file

    if "back".indexOf(command) == 0 then
        if not s isa number then return Console.error(Messages.ErrorUnknownArguments)
        i = 0; while i < s; i = i + 1
            if fd.parent then fd = fd.parent
        end while
        Intrinsics.file = fd
    else if "into".indexOf(command) == 0 then
        fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)
        Intrinsics.file = fd
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "dir", ["ls", "look", "l"], Const.file, Messages.HelpEntryLook, function(arguments)
    lookOne = function(path)
        fd = Intrinsics.file
        fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)

        Console.log(replaceF(Messages.LogContentsOfPath, {"PATH": fd.path}))
        output = Messages.LookHeader
        contents = fd.get_folders + fd.get_files
        for f in contents
            if f.is_folder then 
                type = Messages.Folder
            else if f.is_binary then 
                type = Messages.Binary
            else
                type = Messages.Text
            end if
            permissions = f.permissions
            output = output+char(10)+[permissions[1:],f.owner,f.group,f.size,type,f.name].join(" ")
        end for
        if contents.len == 0 then output = output+char(10)+"- - - - - -"
        
        lines = output.split(char(10))
        namePredicate = function(iItem, jItem)
            iName = iItem.split(" ")[5]
            jName = jItem.split(" ")[5]
            return iName > jName
        end function
        ftPredicate = function(iItem, jItem)
            priority = {
                Messages.Folder: 2,
                Messages.Binary: 1,
                Messages.Text: 0,
            }
            iType = iItem.split(" ")[4]
            jType = jItem.split(" ")[4]
            return priority[iType] < priority[jType]
        end function
        mergeSort(lines, @namePredicate, 1)
        mergeSort(lines, @ftPredicate, 1)
        output = lines.join(char(10))

        output = formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary)
        print(output)
    end function
    
    if arguments.len == 0 then
        lookOne(Intrinsics.file.path)
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for path in arguments
            lookOne(path)
            print(" ")
        end for
        lookOne(last)
    end if
end function


command "more", [], Const.file, Messages.HelpEntryRead, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)

    readOne = function(path)
        fd = Intrinsics.file
        fd = iterateToPath(fd, path)
        if not fd or fd.is_binary or fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotTextFile)
        content = fd.get_content
        if content == null then return Console.error(Messages.ErrorCouldReadFile)
        Console.log(replaceF(Messages.LogContentsOfPath, {"PATH": fd.path}))
        lines = content.split(char(10))
        i = 0; while i < lines.len; i = i + 1
            line = escape(lines[i-1])
            print("<color="+Theme.miscSecondary+">"+str(i-1 + 1)+"<color="+Theme.miscPrimary+">:</color> "+line)
        end while
    end function

    if arguments.len == 1 then
        readOne(str(arguments[0]))
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for path in arguments
            readOne(path)
            print(" ")
        end for
        readOne(last)
    end if
end function


command "del", [], Const.file, Messages.HelpEntryDelete, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)

    deleteOne = function(path)
        fd = iterateToPath(Intrinsics.file, path)
        if not fd then return Console.error(Messages.ErrorPathDoesNotExist)
        if fd.is_folder then
            dirfds = fd.get_folders+fd.get_files
            areAllAccessible = true
            for dirfd in dirfds
                if not dirfd.has_permission("w") then
                    areAllAccessible = false
                    break
                end if
            end for
            if areAllAccessible then
                for dirfd in dirfds
                    yield
                    dirfd.delete
                end for
            end if
        end if
        result = fd.delete
        if result != "" then return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "delete", "ERROR": result}))
        Console.log(replaceF(Messages.LogFileDeletedSuccessfully, {"PATH": fd.path}))
    end function

    for path in fmap(@str, arguments)
        deleteOne(path)
    end for
end function


command "copy", [], Const.file, Messages.HelpEntryCopy, function(arguments)
    Conditions.arguments(arguments, 2)
    
    fd = Intrinsics.file
    path = str(arguments[0])
    dest = str(arguments[1])

    fdSource = iterateToPath(fd, path)
    if not fdSource then return Console.error(Messages.ErrorSourcePathDoesNotExist)
    fileName = fdSource.name

    fdDest = iterateToPath(fd, dest)
    if fdDest and not fdDest.is_folder then
        fileName = fdDest.name
        fdDest = fdDest.parent
    end if
    if not fdDest then
        parts = dest.split("/")
        fileName = parts.pop
        fdDest = iterateToPath(fd, parts.join("/"))
        if not fdDest and parts.len == 0 then fdDest = fd
        if not fdDest then return Console.error(Messages.ErrorDesinationPathDoesNotExist)
    end if

    result = fdSource.copy(fdDest.path, fileName)
    if result isa string then
        Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "copy", "ERROR": result}))
    else if not result then
        Console.error(Messages.ErrorUnknown)
    else
        Console.log(Messages.LogCopiedFileSuccessfully)
    end if
end function


command "tree", [], Const.file, Messages.HelpEntryTree, function(arguments)
    Conditions.arguments(arguments, 0)

    recursefd = function(fd, tab=2)
        print((" "*(tab-2))+"<color="+Theme.miscPrimary+">"+fd.permissions+"</color> "+"<color="+Theme.miscSecondary+">"+fd.path)
        for file in fd.get_files
            print((" "*tab)+"<color="+Theme.miscPrimary+">"+file.permissions+"</color> "+"<color="+Theme.miscSecondary+">"+file.path)
        end for
        for folder in fd.get_folders
            recursefd(folder, tab + 2)
        end for
    end function

    Console.log(Messages.LogFileSystemTree)
    fd = iterateToPath(Intrinsics.file, "/")
    recursefd(fd)
end function
